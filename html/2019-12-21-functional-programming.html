<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Functional Programming</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { font-weight: bold; } /* Alert */
code span.an { font-style: italic; } /* Annotation */
code span.cf { font-weight: bold; } /* ControlFlow */
code span.co { font-style: italic; } /* Comment */
code span.cv { font-style: italic; } /* CommentVar */
code span.do { font-style: italic; } /* Documentation */
code span.dt { text-decoration: underline; } /* DataType */
code span.er { font-weight: bold; } /* Error */
code span.in { font-style: italic; } /* Information */
code span.kw { font-weight: bold; } /* Keyword */
code span.pp { font-weight: bold; } /* Preprocessor */
code span.wa { font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/normalize.css" />
  <link rel="stylesheet" href="../css/skeleton.css" />
  <link rel="stylesheet" href="../css/site.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  		<meta charset="UTF-8">
  		<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono&display=swap" rel="stylesheet">
  		<link href="https://fonts.googleapis.com/css?family=Raleway:300,400&display=swap" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Functional Programming</h1>
</header>
<div class="container">
<p class="notice">
NOTICE: Document not complete
</p>
<h2 id="base-data-types">Base Data Types</h2>
<h3 id="maybe">Maybe</h3>
<div class="sourceCode" id="maybe-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="maybe-definition-1" title="1"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Just</span> a <span class="op">|</span> <span class="dt">Nothing</span></a></code></pre></div>
<h3 id="list">List</h3>
<div class="sourceCode" id="list-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="list-definition-1" title="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a></code></pre></div>
<p>Lists work fine as long as list items remain small.</p>
<div class="sourceCode" id="lazy-list-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="lazy-list-definition-1" title="1"><span class="kw">data</span> <span class="dt">LazyList</span> a <span class="ot">=</span> <span class="dt">LNil</span></a>
<a class="sourceLine" id="lazy-list-definition-2" title="2">                <span class="op">|</span> <span class="dt">LCons</span> (<span class="dt">Lazy</span> (<span class="dt">Pair</span> a (<span class="dt">LazyList</span> a)))</a></code></pre></div>
<div class="sourceCode" id="list"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="list-1" title="1"><span class="kw">infixr</span> <span class="dv">6</span> <span class="dt">Cons</span> as <span class="op">:</span></a></code></pre></div>
<h3 id="array">Array</h3>
<h2 id="basic-type-classes">Basic Type Classes</h2>
<h3 id="basic">Basic</h3>
<div class="sourceCode" id="class-semigroup"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="class-semigroup-1" title="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="class-semigroup-2" title="2"><span class="ot">    append ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<div class="sourceCode" id="class-monoid"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="class-monoid-1" title="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="op">&lt;=</span> <span class="dt">Monoid</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="class-monoid-2" title="2"><span class="ot">    mempty ::</span> a</a></code></pre></div>
<h4 id="basic-instances">Basic Instances</h4>
<h3 id="utility">Utility</h3>
<p>Some functions may diverge towards <code>_|_</code> when given certain values such as dividing by zero which raises an exception. Thus <code>Partial</code> is defined as a nullary class which act as a compile-time assertion that a function and any dervived form it are partial.</p>
<div class="sourceCode" id="partial-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="partial-definition-1" title="1"><span class="kw">class</span> <span class="dt">Partial</span> <span class="kw">where</span></a></code></pre></div>
<p>Conversion between types is common and <code>Cast</code> collects the most usual between any two given types. Being a utility class it has no use other than being convenient.</p>
<div class="sourceCode" id="cast-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cast-definition-1" title="1"><span class="kw">class</span> <span class="dt">Cast</span> from to <span class="kw">where</span></a>
<a class="sourceLine" id="cast-definition-2" title="2"><span class="ot">    cast ::</span> from <span class="ot">-&gt;</span> to</a></code></pre></div>
<p>Some casts may be partial thus require a version capable of failure. If an instance is safe by default the implementation is the same as <code>Cast</code> wrapped in a <code>Just</code>.</p>
<div class="sourceCode" id="safe-cast-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="safe-cast-definition-1" title="1"><span class="kw">class</span> <span class="dt">SafeCast</span> from to <span class="kw">where</span></a>
<a class="sourceLine" id="safe-cast-definition-2" title="2"><span class="ot">    safeCast ::</span> from <span class="ot">-&gt;</span> <span class="dt">Maybe</span> to</a></code></pre></div>
<h4 id="utility-instances">Utility Instances</h4>
<p>Conversion from a <code>LazyList</code> requires forcing every element of the list.</p>
<div class="sourceCode" id="cast-lazylist-list"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cast-lazylist-list-1" title="1"><span class="kw">instance</span> <span class="dt">Cast</span> (<span class="dt">LazyList</span> a) (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cast-lazylist-list-2" title="2">    cast <span class="dt">LNil</span> <span class="ot">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cast-lazylist-list-3" title="3">    cast (<span class="dt">LCons</span> ls) <span class="ot">=</span></a>
<a class="sourceLine" id="cast-lazylist-list-4" title="4">        <span class="kw">let</span> <span class="dt">Pair</span> x ls&#39; <span class="ot">=</span> force ls <span class="kw">in</span> x <span class="op">:</span> cast ls</a></code></pre></div>
<p class="warning">
CAUTION: Passing an infinite list to <code>cast</code> results in <code>_|_</code>
</p>
<div class="sourceCode" id="cast-lazylist-list"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cast-lazylist-list-1" title="1"><span class="kw">instance</span> <span class="dt">SafeCast</span> (<span class="dt">LazyList</span> a) (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cast-lazylist-list-2" title="2">    safeCast <span class="ot">=</span> <span class="dt">Just</span> <span class="op">&lt;&lt;&lt;</span> cast</a></code></pre></div>
<p class="warning">
CAUTION: Passing an infinite list to <code>safeCast</code> results in <code>_|_</code>
</p>
<div class="sourceCode" id="cast-lazylist-list"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cast-lazylist-list-1" title="1"><span class="kw">instance</span> <span class="dt">Cast</span> (<span class="dt">List</span> a) (<span class="dt">LazyList</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cast-lazylist-list-2" title="2">    cast <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">LNil</span></a>
<a class="sourceLine" id="cast-lazylist-list-3" title="3">    cast (<span class="dt">Cons</span> x xs) <span class="ot">=</span></a>
<a class="sourceLine" id="cast-lazylist-list-4" title="4">        <span class="dt">LCons</span> (defer \_ <span class="ot">-&gt;</span> <span class="dt">Pair</span> x (cast xs))</a>
<a class="sourceLine" id="cast-lazylist-list-5" title="5"></a>
<a class="sourceLine" id="cast-lazylist-list-6" title="6"><span class="kw">instance</span> <span class="dt">SafeCast</span> (<span class="dt">List</span> a) (<span class="dt">LazyList</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cast-lazylist-list-7" title="7">    safeCast <span class="ot">=</span> <span class="dt">Just</span> <span class="op">&lt;&lt;&lt;</span> cast</a></code></pre></div>
<h2 id="numerical-type-classes">Numerical Type Classes</h2>
<h3 id="division">Division</h3>
<h4 id="division-implementation">Division Implementation</h4>
<div class="sourceCode" id="int-div-implementation"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="int-div-implementation-1" title="1">foreign <span class="kw">import</span> intDiv :: <span class="dt">Partial</span> =&gt; <span class="dt">Int</span> -&gt; <span class="dt">Int</span> -&gt; <span class="dt">Int</span></a></code></pre></div>
<div class="sourceCode" id="int-div-ffi-implementation"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="int-div-ffi-implementation-1" title="1"><span class="va">exports</span>.<span class="at">intDiv</span> <span class="op">=</span> <span class="kw">function</span> (x) <span class="op">{</span></a>
<a class="sourceLine" id="int-div-ffi-implementation-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> (y) <span class="op">{</span></a>
<a class="sourceLine" id="int-div-ffi-implementation-3" title="3">    <span class="cf">if</span> (y <span class="op">===</span> <span class="dv">0</span>) <span class="cf">throw</span> <span class="st">&quot;NaN&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="int-div-ffi-implementation-4" title="4">    <span class="cf">return</span> y <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="va">Math</span>.<span class="at">floor</span>(x / y) : <span class="op">-</span><span class="va">Math</span>.<span class="at">floor</span>(x / <span class="op">-</span>y)<span class="op">;</span></a>
<a class="sourceLine" id="int-div-ffi-implementation-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="int-div-ffi-implementation-6" title="6"><span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="int-div-implementation"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="int-div-implementation-1" title="1">foreign <span class="kw">import</span> intSafeDiv :: <span class="dt">Int</span> -&gt; <span class="dt">Int</span> -&gt; <span class="dt">Int</span></a></code></pre></div>
<div class="sourceCode" id="int-safe-div-ffi-implementation"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="int-safe-div-ffi-implementation-1" title="1"><span class="va">exports</span>.<span class="at">intSafeDiv</span> <span class="op">=</span> <span class="kw">function</span> (x) <span class="op">{</span></a>
<a class="sourceLine" id="int-safe-div-ffi-implementation-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> (y) <span class="op">{</span></a>
<a class="sourceLine" id="int-safe-div-ffi-implementation-3" title="3">    <span class="cf">if</span> (y <span class="op">===</span> <span class="dv">0</span>) <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="int-safe-div-ffi-implementation-4" title="4">    <span class="cf">return</span> y <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="va">Math</span>.<span class="at">floor</span>(x / y) : <span class="op">-</span><span class="va">Math</span>.<span class="at">floor</span>(x / <span class="op">-</span>y)<span class="op">;</span></a>
<a class="sourceLine" id="int-safe-div-ffi-implementation-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="int-safe-div-ffi-implementation-6" title="6"><span class="op">}</span></a></code></pre></div>
<h2 id="higher-kinded-type-classes">Higher Kinded Type Classes</h2>
<h3 id="functor">Functor</h3>
<div class="sourceCode" id="base-classes"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="base-classes-1" title="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="base-classes-2" title="2"><span class="ot">    map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<h4 id="functor-instances">Functor Instances</h4>
<h3 id="applicative">Applicative</h3>
<div class="sourceCode" id="base-classes"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="base-classes-1" title="1"><span class="kw">class</span> <span class="dt">Pure</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="base-classes-2" title="2"><span class="ot">    pure ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<div class="sourceCode" id="base-classes"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="base-classes-1" title="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="op">&lt;=</span> <span class="dt">Apply</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="base-classes-2" title="2"><span class="ot">    ap ::</span> <span class="kw">forall</span> a b<span class="op">.</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<div class="sourceCode" id="base-classes"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="base-classes-1" title="1"><span class="kw">class</span> (<span class="dt">Apply</span> f, <span class="dt">Pure</span> f) <span class="op">&lt;=</span> <span class="dt">Applicative</span> <span class="kw">where</span></a></code></pre></div>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="op">&lt;=</span> <span class="dt">Selective</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">    select ::</span> f (<span class="dt">Either</span> a b) <span class="ot">-&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b</a></code></pre></div>
<h4 id="applicative-instances">Applicative Instances</h4>
<h3 id="monad">Monad</h3>
<div class="sourceCode" id="bind-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="bind-definition-1" title="1"><span class="kw">class</span> <span class="dt">Apply</span> m <span class="op">&lt;=</span> <span class="dt">Bind</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="bind-definition-2" title="2"><span class="ot">    bind ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="bind-definition-3" title="3"><span class="kw">infixl</span> <span class="dv">1</span> bind as <span class="op">&gt;&gt;=</span></a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> (<span class="dt">Bind</span> m, <span class="dt">Selective</span> m) <span class="op">&lt;=</span> <span class="dt">Monad</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">join ::</span> m (m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb2-4" title="4">join m <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> <span class="fu">id</span></a></code></pre></div>
<h4 id="monad-instances">Monad Instances</h4>
<h3 id="comonad">Comonad</h3>
<div class="sourceCode" id="comonad-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="comonad-definition-1" title="1"><span class="kw">class</span> <span class="dt">Comonad</span> w <span class="kw">where</span></a>
<a class="sourceLine" id="comonad-definition-2" title="2"><span class="ot">    extract ::</span> w a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="comonad-definition-3" title="3"><span class="ot">    extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</a>
<a class="sourceLine" id="comonad-definition-4" title="4"><span class="ot">    duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</a></code></pre></div>
<h4 id="comonad-instances">Comonad Instances</h4>
<h3 id="foldable">Foldable</h3>
<div class="sourceCode" id="foldable-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="foldable-definition-1" title="1"><span class="kw">class</span> <span class="dt">Foldable</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="foldable-definition-2" title="2"><span class="ot">    foldr ::</span> <span class="kw">forall</span> t a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="foldable-definition-3" title="3"><span class="ot">    foldl ::</span> <span class="kw">forall</span> t a b<span class="op">.</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a></code></pre></div>
<div class="sourceCode" id="recursive-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="recursive-definition-1" title="1"><span class="kw">type</span> <span class="dt">Algebra</span> f t <span class="ot">=</span> f t <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="recursive-definition-2" title="2"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="op">&lt;=</span> <span class="dt">Recursive</span> f t <span class="op">|</span> f <span class="ot">-&gt;</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="recursive-definition-3" title="3"><span class="ot">    project ::</span> t <span class="ot">-&gt;</span> f t</a></code></pre></div>
<h4 id="foldable-instances">Foldable Instances</h4>
<pre><code>cata :: forall f t a. Recursive f t =&gt; Algebra f a -&gt; t -&gt; a
cata f = c where c x = f (map c (project x))</code></pre>
<h3 id="unfoldable">Unfoldable</h3>
<div class="sourceCode" id="corecursive-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="corecursive-definition-1" title="1"><span class="kw">type</span> <span class="dt">CoAlgebra</span> f t <span class="ot">=</span> t <span class="ot">-&gt;</span> f t</a>
<a class="sourceLine" id="corecursive-definition-2" title="2"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="op">&lt;=</span> <span class="dt">CoRecursive</span> f t <span class="op">|</span> f <span class="ot">-&gt;</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="corecursive-definition-3" title="3"><span class="ot">    embed ::</span> f t <span class="ot">-&gt;</span> t</a></code></pre></div>
<h4 id="unfoldable-instances">Unfoldable Instances</h4>
<pre><code>ana :: forall f t a. CoRecursive f t =&gt; CoAlgebra f a -&gt; a -&gt; t
ana g = a where a x = embed (map a (g x))</code></pre>
<h2 id="categories">Categories</h2>
<h3 id="category">Category</h3>
<div class="sourceCode" id="semigroupoid-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="semigroupoid-definition-1" title="1"><span class="kw">class</span> <span class="dt">Semigroupoid</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="semigroupoid-definition-2" title="2"><span class="ot">    compose ::</span> k b c <span class="ot">-&gt;</span> k a b <span class="ot">-&gt;</span> k a c</a>
<a class="sourceLine" id="semigroupoid-definition-3" title="3"></a>
<a class="sourceLine" id="semigroupoid-definition-4" title="4"><span class="kw">infixr</span> <span class="dv">10</span> compose as <span class="op">&lt;&lt;&lt;</span></a>
<a class="sourceLine" id="semigroupoid-definition-5" title="5"></a>
<a class="sourceLine" id="semigroupoid-definition-6" title="6"><span class="ot">flippedCompose ::</span> <span class="dt">Semigroupoid</span> k <span class="ot">=&gt;</span> k a b <span class="ot">-&gt;</span> k b c <span class="ot">-&gt;</span> k a c</a>
<a class="sourceLine" id="semigroupoid-definition-7" title="7">flippedCompose <span class="ot">=</span> <span class="fu">flip</span> compose</a>
<a class="sourceLine" id="semigroupoid-definition-8" title="8"></a>
<a class="sourceLine" id="semigroupoid-definition-9" title="9"><span class="kw">infixl</span> <span class="dv">10</span> compose as <span class="op">&gt;&gt;&gt;</span></a></code></pre></div>
<div class="sourceCode" id="category-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="category-definition-1" title="1"><span class="kw">class</span> <span class="dt">Semigroupoid</span> k <span class="op">&lt;=</span> <span class="dt">Category</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="category-definition-2" title="2"><span class="ot">    id ::</span> k a a</a></code></pre></div>
<div class="sourceCode" id="cartesian-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cartesian-definition-1" title="1"><span class="kw">class</span> <span class="dt">Category</span> k <span class="op">&lt;=</span> <span class="dt">Cartesian</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cartesian-definition-2" title="2"><span class="ot">    fst ::</span> k (<span class="dt">Pair</span> a b) a</a>
<a class="sourceLine" id="cartesian-definition-3" title="3"><span class="ot">    snd ::</span> k (<span class="dt">Pair</span> a b) b</a>
<a class="sourceLine" id="cartesian-definition-4" title="4"><span class="ot">    dup ::</span> k a (<span class="dt">Pair</span> a a)</a></code></pre></div>
<div class="sourceCode" id="cocartesian-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cocartesian-definition-1" title="1"><span class="kw">class</span> <span class="dt">Category</span> k <span class="op">&lt;=</span> <span class="dt">CoCartesian</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cocartesian-definition-2" title="2"><span class="ot">    left ::</span> k a (<span class="dt">Either</span> a b)</a>
<a class="sourceLine" id="cocartesian-definition-3" title="3"><span class="ot">    right ::</span> k b (<span class="dt">Either</span> a b)</a>
<a class="sourceLine" id="cocartesian-definition-4" title="4"><span class="ot">    jam ::</span> k (<span class="dt">Either</span> a a) a</a></code></pre></div>
<div class="sourceCode" id="closed-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="closed-definition-1" title="1"><span class="kw">class</span> (<span class="dt">CoCartesian</span> k, <span class="dt">Cartesian</span> k) <span class="op">&lt;=</span> <span class="dt">Closed</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="closed-definition-2" title="2"><span class="ot">    apply ::</span> k (<span class="dt">Pair</span> (k a b) a) b</a>
<a class="sourceLine" id="closed-definition-3" title="3"><span class="ot">    curry ::</span> k (k a b) c <span class="ot">-&gt;</span> k a (k b c)</a>
<a class="sourceLine" id="closed-definition-4" title="4"><span class="ot">    uncurry ::</span> k a (k b c) <span class="ot">-&gt;</span> k (k a b) c</a></code></pre></div>
<div class="sourceCode" id="terminal-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="terminal-definition-1" title="1"><span class="kw">class</span> <span class="dt">Terminal</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="terminal-definition-2" title="2"><span class="ot">    it ::</span> k a <span class="dt">Unit</span></a></code></pre></div>
<h4 id="category-instances">Category Instances</h4>
<div class="sourceCode" id="semigroupoid-function-instance"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="semigroupoid-function-instance-1" title="1"><span class="kw">instance</span> <span class="dt">Semigroupoid</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="semigroupoid-function-instance-2" title="2">    compose f g x <span class="ot">=</span> f (g x)</a></code></pre></div>
<div class="sourceCode" id="category-function-instance"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="category-function-instance-1" title="1"><span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="category-function-instance-2" title="2">    <span class="fu">id</span> x <span class="ot">=</span> x</a></code></pre></div>
<div class="sourceCode" id="cartesian-function-instance"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cartesian-function-instance-1" title="1"><span class="kw">instance</span> <span class="dt">Cartesian</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cartesian-function-instance-2" title="2">    <span class="fu">fst</span> (<span class="dt">Pair</span> a _) <span class="ot">=</span> a</a>
<a class="sourceLine" id="cartesian-function-instance-3" title="3">    <span class="fu">snd</span> (<span class="dt">Pair</span> _ b) <span class="ot">=</span> b</a>
<a class="sourceLine" id="cartesian-function-instance-4" title="4">    dup a <span class="ot">=</span> <span class="dt">Pair</span> a a</a></code></pre></div>
<div class="sourceCode" id="terminal-function-instance"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="terminal-function-instance-1" title="1"><span class="kw">instance</span> <span class="dt">Terminal</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="terminal-function-instance-2" title="2">    it _ <span class="ot">=</span> <span class="dt">Unit</span></a></code></pre></div>
<h2 id="lazy-evaluation">Lazy Evaluation</h2>
<p>Lazy evaluation opens up a world of new patterns of infinite structure allowing for a truly declarative style. With lazy semantics it’s possible to write types such as <code>Stream</code> which represents infinite lists, <code>Wire</code> representing time varying values in intinite stepped computations, and so on.</p>
<p>In this section we’ll be implementing our own lazy evaluation library and see how instances change along with concerns involving the performance of such. It includes one purescript module <code>Data.Lazy</code>.</p>
<div class="sourceCode" id="cb5" data-file="src/purescript/FunctionalProgramming/Data/Lazy.purs"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">module</span> <span class="dt">Lazy</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="op">&lt;&lt;</span>lazy<span class="op">-</span>definition<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="op">&lt;&lt;</span>lazy<span class="op">-</span>numerical<span class="op">-</span>instances<span class="op">&gt;&gt;</span></a></code></pre></div>
<p>And one javascript module implementing the runtime.</p>
<div class="sourceCode" id="cb6" data-file="src/purescript/FunctionalProgramming/Data/Lazy.js"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&lt;&lt;</span>lazy<span class="op">-</span>js<span class="op">-</span>definition<span class="op">&gt;&gt;</span></a></code></pre></div>
<h3 id="definition">Definition</h3>
<p>We begin by declaring an abstract type <code>Lazy</code> to represent defered computation.</p>
<div class="sourceCode" id="lazy-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="lazy-definition-1" title="1">foreign <span class="kw">import</span> data <span class="dt">Lazy</span> :: <span class="dt">Type</span> -&gt; <span class="dt">Type</span></a></code></pre></div>
<p>Since lazy evaluation is external to purescript it won’t be able to deconstruct <code>Lazy</code> inside purescript. Instead we’ll define <code>defer</code> taking a closure which it turns into a thunk to be evaluated later and <code>force</code> which evaluates the thunk in javascript.</p>
<div class="sourceCode" id="lazy-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="lazy-definition-1" title="1">foreign <span class="kw">import</span> defer :: a -&gt; <span class="dt">Lazy</span> a</a>
<a class="sourceLine" id="lazy-definition-2" title="2">foreign <span class="kw">import</span> force :: <span class="dt">Lazy</span> a -&gt; a</a></code></pre></div>
<p>The machinery behind lazy evaluation is captured by <code>defer</code> which makes use of mutable state behind the scenes.</p>
<p>First <code>defer</code> allocates a mutable variable <code>value</code> which will house the result once computed and takes a computation <code>thunk</code> which when run will give that value. Then <code>value</code> is captured in a new closure <code>lazy-js-closure</code> containing the thunk to be run later.</p>
<div class="sourceCode" id="lazy-js-definition"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="lazy-js-definition-1" title="1"><span class="va">exports</span>.<span class="at">defer</span> <span class="op">=</span> <span class="kw">function</span>(thunk) <span class="op">{</span></a>
<a class="sourceLine" id="lazy-js-definition-2" title="2">    <span class="kw">var</span> value <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="lazy-js-definition-3" title="3">    <span class="cf">return</span> <span class="op">&lt;&lt;</span>lazy<span class="op">-</span>js<span class="op">-</span>closure<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="lazy-js-definition-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>Upon the first execution of <code>lazy-js-closure</code> the <code>thunk</code> is defined and <code>value</code> is <code>null</code> thus the condition doesn’t fire. The sequence continues with setting <code>value</code> to the result of evaluating <code>thunk</code> and clearing <code>thunk</code> allowing the computation to be freed from memory before returing the result. For every use after <code>thunk</code> will still be <code>undefined</code> and <code>value</code> set which causes the condition to fire and result returned without recomputing <code>value</code>.</p>
<div class="sourceCode" id="lazy-js-closure"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="lazy-js-closure-1" title="1"><span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="lazy-js-closure-2" title="2">    <span class="cf">if</span> (thunk <span class="op">===</span> <span class="kw">undefined</span>) <span class="cf">return</span> value<span class="op">;</span></a>
<a class="sourceLine" id="lazy-js-closure-3" title="3">    value <span class="op">=</span> <span class="at">thunk</span>()<span class="op">;</span></a>
<a class="sourceLine" id="lazy-js-closure-4" title="4">    thunk <span class="op">=</span> <span class="kw">undefined</span><span class="op">;</span></a>
<a class="sourceLine" id="lazy-js-closure-5" title="5">    <span class="cf">return</span> value<span class="op">;</span></a>
<a class="sourceLine" id="lazy-js-closure-6" title="6"><span class="op">}</span></a></code></pre></div>
By keeping the result around and throwing away the computation thunk we’ve implemented sharing of immutable values and on-demand evaluation which is the core of lazy evaluation.
<details>
<summary>note</summary>
<p class="notice">
There are other ways to implement lazy evaluation besides the one shown here. For example, a compiler may inline the conditional branch at the location of <code>force</code> along with procedures called after to eliminate the overhead of calling. However, implementation of such is out of scope for this article.
</p>
</details>
<p><code>force</code> is considerably simpler in it’s definition. The closure ready to be evaluated, <code>force</code> only needs to invoke it to get the result.</p>
<div class="sourceCode" id="lazy-js-definition"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="lazy-js-definition-1" title="1"><span class="va">exports</span>.<span class="at">force</span> <span class="op">=</span> <span class="kw">function</span>(closure) <span class="op">{</span></a>
<a class="sourceLine" id="lazy-js-definition-2" title="2">    <span class="cf">return</span> <span class="at">closure</span>()<span class="op">;</span></a>
<a class="sourceLine" id="lazy-js-definition-3" title="3"><span class="op">}</span></a></code></pre></div>
<h3 id="numerical-instances">Numerical Instances</h3>
<h3 id="functor-applicative-instances">Functor &amp; Applicative Instances</h3>
<h2 id="hash">Hash</h2>
<h3 id="definition-1">Definition</h3>
<h4 id="fnv1a">FNV1a</h4>
<p class="warning">
CAUTION: <code>fnv1a</code> is a non-cryptographic hash function and should never be used in place of a cryptographic hash function.
</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="dt">FNV1aImpl</span> a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">    fnv1aImpl ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">fnv1a32 ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">FNV1a</span> a <span class="dt">Int</span> <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" title="2">fnv1a32 x <span class="ot">=</span> fnv1aImpl x offset prime</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">where</span> offset <span class="ot">=</span> <span class="dv">2166136261</span> <span class="co">-- TODO change to unsigned</span></a>
<a class="sourceLine" id="cb8-4" title="4">          prime <span class="ot">=</span> <span class="dv">16777619</span> <span class="co">-- TODO change to unsigned</span></a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">instance</span><span class="ot"> fnv1a_int ::</span> <span class="dt">FNV1a</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" title="2">    fnv1aImpl x offset prime <span class="ot">=</span> (offset <span class="ot">`xor`</span> x) <span class="op">*</span> prime</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">instance</span><span class="ot"> fnv1a_list ::</span> <span class="dt">FNV1a</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" title="2">    fnv1a32 x offset prime <span class="ot">=</span></a></code></pre></div>
<h4 id="djb2">djb2</h4>
<p class="warning">
CAUTION: <code>djb2</code> is a non-cryptographic hash function and should never be used in place of a cryptographic hash function.
</p>
<h2 id="stream">Stream</h2>
<h3 id="definition-2">Definition</h3>
<div class="sourceCode" id="stream-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="stream-definition-1" title="1"><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">SCons</span> (<span class="dt">Lazy</span> (<span class="dt">Pair</span> a (<span class="dt">Stream</span> a)))</a></code></pre></div>
<div class="sourceCode" id="stream-cast"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="stream-cast-1" title="1"><span class="kw">instance</span> <span class="dt">Cast</span> (<span class="dt">Stream</span> a) (<span class="dt">LazyList</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="stream-cast-2" title="2">    cast (<span class="dt">SCons</span> s) <span class="ot">=</span> <span class="dt">LCons</span> (delay \_ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="stream-cast-3" title="3">        <span class="kw">let</span> <span class="dt">Pair</span> x ss <span class="ot">=</span> force s <span class="kw">in</span></a>
<a class="sourceLine" id="stream-cast-4" title="4">            <span class="dt">Pair</span> x (cast ss))</a></code></pre></div>
<details>
<summary>note</summary>
<p class="notice">
While it’s possible to create an instance of <code>safeCast</code> for <code>LazyList</code> to <code>Stream</code> casts it’s inefficient and doesn’t result in any advantages over using <code>LazyList</code> directly.
</p>
</details>
<h2 id="wire">Wire</h2>
<p><code>Stream</code> is great for tasks where you can define the set of possible values up front while not taking into account the past states. While this works great for random numbers, spreadsheets, and similar it doesn’t fare so well when we need that state. Wires are stateful where the next value is derived from an input value and the past state while keeping the properties we like of streams.</p>
<p>This section covers the design and implementation of the <code>Control.Wire</code> library along with the many utilities that come with it and since this is a pure purescript module there are only a few files to keep track of.</p>
<p><code>Control.Wire</code> exports the wire prelude consisting of a collection of support modules and the most frequently used wires.</p>
<div class="sourceCode" id="cb11" data-file="src/purescript/FunctionalProgramming/Control/Wire.purs"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">module</span> <span class="dt">Control.Wire</span> (<span class="kw">module</span> <span class="dt">X</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">import</span> <span class="dt">Control.Wire.Core</span> <span class="kw">as</span> <span class="dt">X</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">import</span> <span class="dt">Control.Wire.Event</span> <span class="kw">as</span> <span class="dt">X</span></a></code></pre></div>
<p><code>Control.Wire.Core</code> exports the core data structure and definitions.</p>
<div class="sourceCode" id="cb12" data-file="src/purescript/FunctionalProgramming/Control/Wire/Core.purs"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">module</span> <span class="dt">Control.Wire.Core</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="op">&lt;&lt;</span>wire<span class="op">-</span>definition<span class="op">&gt;&gt;</span></a></code></pre></div>
<h3 id="definition-3">Definition</h3>
<div class="sourceCode" id="wire-definition"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="wire-definition-1" title="1"><span class="kw">data</span> <span class="dt">Wire</span> m a b <span class="kw">where</span></a>
<a class="sourceLine" id="wire-definition-2" title="2">    <span class="dt">Wire</span> (a <span class="ot">-&gt;</span> m (<span class="dt">Pair</span> (<span class="dt">Lazy</span> (<span class="dt">Wire</span> m a b)) b))</a></code></pre></div>
<div class="sourceCode" id="wire-semigroupoid"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="wire-semigroupoid-1" title="1"><span class="kw">instance</span> <span class="dt">Semigroupoid</span> (<span class="dt">Wire</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="wire-semigroupoid-2" title="2">    compose (<span class="dt">Wire</span> f) (<span class="dt">Wire</span> g) <span class="ot">=</span> <span class="dt">Wire</span> \x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="wire-semigroupoid-3" title="3">        <span class="kw">let</span> <span class="dt">Pair</span> g&#39; x&#39; <span class="ot">=</span> g x</a>
<a class="sourceLine" id="wire-semigroupoid-4" title="4">            <span class="dt">Pair</span> f&#39; x&#39;&#39; <span class="ot">=</span> f x&#39;</a>
<a class="sourceLine" id="wire-semigroupoid-5" title="5">         <span class="kw">in</span> <span class="dt">Pair</span> (compose (force f&#39;) (force g&#39;)) x&#39;&#39;</a></code></pre></div>
<div class="sourceCode" id="wire-category"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="wire-category-1" title="1"><span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">Wire</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="wire-category-2" title="2">    <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Wire</span> \x <span class="ot">-&gt;</span> <span class="dt">Pair</span> (delay \_ <span class="ot">-&gt;</span> <span class="fu">id</span>) x</a></code></pre></div>
<div class="sourceCode" id="wire-loop"><pre class="sourceCode hs"><code class="sourceCode haskell"></code></pre></div>
<h3 id="events">Events</h3>
<h2 id="io">IO</h2>
<div class="sourceCode" id="io"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="io-1" title="1">foreign <span class="kw">import</span> data <span class="dt">IO</span> :: <span class="dt">Type</span> -&gt; <span class="dt">Type</span></a>
<a class="sourceLine" id="io-2" title="2"></a>
<a class="sourceLine" id="io-3" title="3">foreign <span class="kw">import</span> pureIO :: forall a. a -&gt; <span class="dt">IO</span> a</a>
<a class="sourceLine" id="io-4" title="4">foreign <span class="kw">import</span> apIO :: forall a b. <span class="dt">IO</span> (a -&gt; b) -&gt; <span class="dt">IO</span> a -&gt; <span class="dt">IO</span> b</a>
<a class="sourceLine" id="io-5" title="5">foreign <span class="kw">import</span> mapIO :: forall a b. (a -&gt; b) -&gt; <span class="dt">IO</span> a -&gt; <span class="dt">IO</span> b</a>
<a class="sourceLine" id="io-6" title="6">foreign <span class="kw">import</span> bindIO :: forall a b. <span class="dt">IO</span> a -&gt; (a -&gt; <span class="dt">IO</span> b) -&gt; <span class="dt">IO</span> b</a>
<a class="sourceLine" id="io-7" title="7"></a>
<a class="sourceLine" id="io-8" title="8"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">IO</span> <span class="kw">where</span></a>
<a class="sourceLine" id="io-9" title="9">    <span class="fu">map</span> <span class="ot">=</span> mapIO</a>
<a class="sourceLine" id="io-10" title="10"></a>
<a class="sourceLine" id="io-11" title="11"><span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">IO</span> <span class="kw">where</span></a>
<a class="sourceLine" id="io-12" title="12">    ap <span class="ot">=</span> apIO</a></code></pre></div>
<h3 id="canvas">Canvas</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">foreign <span class="kw">import</span> data <span class="dt">Canvas</span> :: <span class="dt">Type</span></a>
<a class="sourceLine" id="cb13-2" title="2">foreign <span class="kw">import</span> data <span class="dt">Context2D</span> :: <span class="dt">Type</span></a>
<a class="sourceLine" id="cb13-3" title="3">foreign <span class="kw">import</span> createCanvas :: <span class="dt">Int</span> -&gt; <span class="dt">Int</span> -&gt; <span class="dt">String</span> -&gt; <span class="dt">IO</span> <span class="dt">Canvas</span></a>
<a class="sourceLine" id="cb13-4" title="4">foreign <span class="kw">import</span> getContext2D :: <span class="dt">Canvas</span> -&gt; <span class="dt">IO</span> <span class="dt">Context2D</span></a>
<a class="sourceLine" id="cb13-5" title="5">foreign <span class="kw">import</span> setCtxFillStyle :: <span class="dt">String</span> -&gt; <span class="dt">IO</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb13-6" title="6">foreign <span class="kw">import</span> setCtxFillRect :: <span class="dt">Int</span> -&gt; <span class="dt">Int</span> -&gt; <span class="dt">Int</span> -&gt; <span class="dt">Int</span> -&gt; <span class="dt">IO</span> <span class="dt">Unit</span></a></code></pre></div>
<h3 id="animation">Animation</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">foreign <span class="kw">import</span> requestAnimationFrame :: (<span class="dt">Unit</span> -&gt; <span class="dt">IO</span> <span class="dt">Unit</span>) -&gt; <span class="dt">IO</span> <span class="dt">Unit</span></a></code></pre></div>
</div>
</body>
</html>
